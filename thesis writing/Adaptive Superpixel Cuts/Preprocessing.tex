As mentioned in Section \ref{Cube}, the input to the algorithm is a hyperspectral image represented by a nonegative tensor $\mathbf{X} \in \mathbb{R}_+^{n_x \times n_y \times n_\lambda}$. Raw hyperspectral images are susceptible to outliers and scale invariance across wavelengths. As such, to ensure algorithms perform reliably along a wide range of domains, preprocessing is a crucial step. Typically, the first main goal of practioners is to deal with noise and regularization across the spectral dimension, then work to deal with spatial artifacts in the image. 
Hyperspectral images often have bands with significantly higher intensity values compared to others. It is important to consider the full collection of wavelengths rather than allow the overprioritization of higher intensity wavelengths, especially in situations where direct scale comparison is made between pixels. By normalizing each spectral band to a similar scale, all spectral bands contribute more equally to the segmentation process. This ensures that results capture the underlying spectral information more effectively. A common approach to normalization in hyperspectral images is band normalization, where intesity values for the hyperspectral image at spectral band $k$, denoted $\mathbf{X}_{(\cdot, \cdot, k)}$ are independently scaled to a range $[0,1]$ according to the minimum and maximum values at that band. Formally,
\begin{equation}
    \label{alg:normalization}
    \hat{\mathbf{X}}_{(\cdot, \cdot, k)} =  \frac{\mathbf{X}_{(\cdot, \cdot, k)} - \min\mathbf{X}_{(\cdot, \cdot, k)}}{\max\mathbf{X}_{(\cdot, \cdot, k)} - \min\mathbf{X}_{(\cdot, \cdot, k)}}.
\end{equation}

% $\mathbf{X}$ can be alternatively represented using matrix $\mathbf{X}_f \in \mathbb{R}_+^{(n_p, n_\lambda)}$, where $n_p = n_x n_y$ is the total number of pixels in the image, with each column representing the pixel at index $(i,j)$ in $\mathbf{X}$, arranged across the first spectral dimension, then the second. Formally, $
% \mathbf{X}_f = \left[ \mathbf{x}_{(0,0)},  \cdots, \mathbf{x}_{(n_x,0)}, \cdots, \mathbf{x}_{(0,n_y)}, \cdots, \mathbf{x}_{(n_x, n_y)} \right] $. 

